C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE LCD_8BIT
OBJECT MODULE PLACED IN .\output\LCD-8bit.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\lib\lcd-2.4_2.8\LCD-8bit.c BROWSE INCDIR(..\lib) DEBUG OBJECTEXTEND PRIN
                    -T(.\output\LCD-8bit.lst) OBJECT(.\output\LCD-8bit.obj)

line level    source

   1          // Copyright 2015 @ Sunrom Electronics www.sunrom.com
   2          #include <reg51.h>
   3          #include <intrins.h>
   4          #include <font\font.h>
   5          #include <sys\sys.h>
   6          #include <lcd-2.4_2.8\lcd-8bit.h>
   7          /*
   8          Hardware Setup: 
   9                  Microchip SST89V516RD
  10                  Crystal 22.1184 Mhz 
  11                  Operating voltage of 3.3V
  12          
  13          IO connections between MCU and LCD:
  14                  Data Low: 
  15                          LCD(DB0-DB7) = P0^0-P0^7; (Ignore-No Connect if LCD operated in 8-bit mode which is default)
  16                  Data High: 
  17                          LCD(DB8-DB15) = P2^0-P2^7;
  18                  Control: 
  19                          LCD_RS = P3^5; 
  20                          LCD_WR = P3^6;
  21                          LCD_RD = P3^7;
  22                          LCD_CS = P1^0;
  23                          LCD_RESET = P1^2;
  24                  Touch(Optional):
  25                  T_CLK = P1^7; 
  26                  T_CS = P1^4; 
  27                  T_DIN = P3^0; 
  28                  T_DOUT = P3^1; 
  29                  T_IRQ = P3^4;
  30          */
  31          
  32          u16 BACK_COLOR, POINT_COLOR;   //Background color, brush color
  33          
  34          #ifdef  Bus_16    //Conditional compilation -16-bit data mode 
              void LCD_Writ_Bus(char VH,char VL)   //Parallel Data Write function
              {
                  LCD_DataPortH=VH;   
                      LCD_DataPortL=VL;               
                      LCD_WR=0;
                      LCD_WR=1; 
              }
              #else                   //Conditional compilation -8-bit data mode
  43          void LCD_Writ_Bus(char VH,char VL)   //Parallel Data Write function
  44          {       
  45   1          LCD_DataPortH=VH;   
  46   1              LCD_WR=0;
  47   1              LCD_WR=1;
  48   1              LCD_DataPortH=VL;               
  49   1              LCD_WR=0;
  50   1              LCD_WR=1;
  51   1      }
  52          #endif
  53          void LCD_WR_DATA8(char VH,char VL) //Send -8 bit parameter data
  54          {
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 2   

  55   1          LCD_RS=1;
  56   1              LCD_Writ_Bus(VH,VL);
  57   1      }  
  58           void LCD_WR_DATA(int da)
  59          {
  60   1          LCD_RS=1;
  61   1              LCD_Writ_Bus(da>>8,da);
  62   1      }         
  63          void LCD_WR_REG(int da)  
  64          {       
  65   1          LCD_RS=0;
  66   1              LCD_Writ_Bus(da>>8,da);
  67   1      }
  68           void LCD_WR_REG_DATA(int reg,int da)
  69          {
  70   1          LCD_WR_REG(reg);
  71   1              LCD_WR_DATA(da);
  72   1      }
  73          void Address_set(unsigned int x1,unsigned int y1,unsigned int x2,unsigned int y2)
  74          { 
  75   1              LCD_WR_REG(0x0020);LCD_WR_DATA8(x1>>8,x1);        // Set the X coordinate position
  76   1          LCD_WR_REG(0x0021);LCD_WR_DATA8(y1>>8,y1);   // Set the Y coordinate position
  77   1          LCD_WR_REG(0x0050);LCD_WR_DATA8(x1>>8,x1);   //Start X
  78   1              LCD_WR_REG(0x0052);LCD_WR_DATA8(y1>>8,y1);        //Start Y
  79   1          LCD_WR_REG(0x0051);LCD_WR_DATA8(x2>>8,x2);   //End X
  80   1              LCD_WR_REG(0x0053);LCD_WR_DATA8(y2>>8,y2);   //End Y
  81   1          LCD_WR_REG(0x0022);                                                                                                  
  82   1      }
  83          void Lcd_Init(void)
  84          {
  85   1      
  86   1      // Call the function once, so the compiler when prompted warnings
  87   1              LCD_CS =1;
  88   1              if(LCD_CS==0)
  89   1              {
  90   2                 LCD_WR_REG_DATA(0,0);
  91   2                 LCD_ShowString(0,0," ");
  92   2                 LCD_ShowNum(0,0,0,0);
  93   2                 LCD_Show2Num(0,0,0,0);
  94   2                 LCD_DrawPoint_big(0,0);
  95   2                 LCD_DrawRectangle(0,0,0,0);
  96   2                 Draw_Circle(0,0,0);
  97   2               }
  98   1      
  99   1          LCD_REST=1;
 100   1          delayms(5); 
 101   1              LCD_REST=0;
 102   1              delayms(5);
 103   1              LCD_REST=1;
 104   1              LCD_CS=1;
 105   1              LCD_RD=1;
 106   1              LCD_WR=1;
 107   1              delayms(5);
 108   1              LCD_CS =0;  // Open the chip enable
 109   1      
 110   1      LCD_WR_REG_DATA(0x0001,0x0100); 
 111   1       LCD_WR_REG_DATA(0x0002,0x0700); 
 112   1       LCD_WR_REG_DATA(0x0003,0x1030); 
 113   1       LCD_WR_REG_DATA(0x0004,0x0000); 
 114   1       LCD_WR_REG_DATA(0x0008,0x0207);  
 115   1       LCD_WR_REG_DATA(0x0009,0x0000);
 116   1       LCD_WR_REG_DATA(0x000A,0x0000); 
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 3   

 117   1       LCD_WR_REG_DATA(0x000C,0x0000); 
 118   1       LCD_WR_REG_DATA(0x000D,0x0000);
 119   1       LCD_WR_REG_DATA(0x000F,0x0000);
 120   1      //power on sequence VGHVGL
 121   1       LCD_WR_REG_DATA(0x0010,0x0000);   
 122   1       LCD_WR_REG_DATA(0x0011,0x0007);  
 123   1       LCD_WR_REG_DATA(0x0012,0x0000);  
 124   1       LCD_WR_REG_DATA(0x0013,0x0000); 
 125   1      //vgh 
 126   1       LCD_WR_REG_DATA(0x0010,0x1290);   
 127   1       LCD_WR_REG_DATA(0x0011,0x0227);
 128   1       //delayms(100);
 129   1       //vregiout 
 130   1       LCD_WR_REG_DATA(0x0012,0x001d); //0x001b
 131   1       //delayms(100); 
 132   1       //vom amplitude
 133   1       LCD_WR_REG_DATA(0x0013,0x1500);
 134   1       //delayms(100); 
 135   1       //vom H
 136   1       LCD_WR_REG_DATA(0x0029,0x0018); 
 137   1       LCD_WR_REG_DATA(0x002B,0x000D); 
 138   1      
 139   1      //gamma
 140   1       LCD_WR_REG_DATA(0x0030,0x0004);
 141   1       LCD_WR_REG_DATA(0x0031,0x0307);
 142   1       LCD_WR_REG_DATA(0x0032,0x0002);// 0006
 143   1       LCD_WR_REG_DATA(0x0035,0x0206);
 144   1       LCD_WR_REG_DATA(0x0036,0x0408);
 145   1       LCD_WR_REG_DATA(0x0037,0x0507); 
 146   1       LCD_WR_REG_DATA(0x0038,0x0204);//0200
 147   1       LCD_WR_REG_DATA(0x0039,0x0707); 
 148   1       LCD_WR_REG_DATA(0x003C,0x0405);// 0504
 149   1       LCD_WR_REG_DATA(0x003D,0x0F02); 
 150   1       //ram
 151   1       LCD_WR_REG_DATA(0x0050,0x0000); 
 152   1       LCD_WR_REG_DATA(0x0051,0x00EF);
 153   1       LCD_WR_REG_DATA(0x0052,0x0000); 
 154   1       LCD_WR_REG_DATA(0x0053,0x013F);  
 155   1       LCD_WR_REG_DATA(0x0060,0xA700); 
 156   1       LCD_WR_REG_DATA(0x0061,0x0001); 
 157   1       LCD_WR_REG_DATA(0x006A,0x0000); 
 158   1       //
 159   1       LCD_WR_REG_DATA(0x0080,0x0000); 
 160   1       LCD_WR_REG_DATA(0x0081,0x0000); 
 161   1       LCD_WR_REG_DATA(0x0082,0x0000); 
 162   1       LCD_WR_REG_DATA(0x0083,0x0000); 
 163   1       LCD_WR_REG_DATA(0x0084,0x0000); 
 164   1       LCD_WR_REG_DATA(0x0085,0x0000); 
 165   1       //
 166   1       LCD_WR_REG_DATA(0x0090,0x0010); 
 167   1       LCD_WR_REG_DATA(0x0092,0x0600); 
 168   1       LCD_WR_REG_DATA(0x0093,0x0003); 
 169   1       LCD_WR_REG_DATA(0x0095,0x0110); 
 170   1       LCD_WR_REG_DATA(0x0097,0x0000); 
 171   1       LCD_WR_REG_DATA(0x0098,0x0000);
 172   1       LCD_WR_REG_DATA(0x0007,0x0133);
 173   1      
 174   1      }
 175          // Clear screen function
 176          //Color:To clear the screen filled with color
 177          void LCD_Clear(u16 Color)
 178          {
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 4   

 179   1              u8 VH,VL;
 180   1              u16 i,j;
 181   1              VH=Color>>8;
 182   1              VL=Color;       
 183   1              Address_set(0,0,LCD_W-1,LCD_H-1);
 184   1          for(i=0;i<LCD_W;i++)
 185   1               {
 186   2                for (j=0;j<LCD_H;j++)
 187   2                      {
 188   3                       LCD_WR_DATA8(VH,VL);
 189   3                  }
 190   2      
 191   2                }
 192   1      }
 193          //Dotted
 194          //POINT_COLOR:The color of this point
 195          void LCD_DrawPoint(u16 x,u16 y)
 196          {
 197   1              Address_set(x,y,x,y);//Setting the cursor position
 198   1              LCD_WR_DATA(POINT_COLOR);           
 199   1      }        
 200          // Draw a big point
 201          //POINT_COLOR:The color of this point
 202          void LCD_DrawPoint_big(u16 x,u16 y)
 203          {
 204   1              LCD_Fill(x-1,y-1,x+1,y+1,POINT_COLOR);
 205   1      } 
 206          // Fill in the designated area specified color
 207          // Size of the area:
 208          //  (xend-xsta)*(yend-ysta)
 209          void LCD_Fill(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)
 210          {          
 211   1              u16 i,j; 
 212   1              Address_set(xsta,ysta,xend,yend);      //Setting the cursor position
 213   1              for(i=ysta;i<=yend;i++)
 214   1              {                                                                                                                       
 215   2                      for(j=xsta;j<=xend;j++)LCD_WR_DATA(color);//Setting the cursor position    
 216   2              }                                                   
 217   1      }  
 218          // Draw the line
 219          //x1,y1:Starting point coordinates
 220          //x2,y2:End coordinates
 221          void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)
 222          {
 223   1              u16 t; 
 224   1              int xerr=0,yerr=0,delta_x,delta_y,distance; 
 225   1              int incx,incy,uRow,uCol; 
 226   1      
 227   1              delta_x=x2-x1; //Calculate the coordinates of the incremental
 228   1              delta_y=y2-y1; 
 229   1              uRow=x1; 
 230   1              uCol=y1; 
 231   1              if(delta_x>0)incx=1; //Set single-step directions
 232   1              else if(delta_x==0)incx=0;//Vertical line
 233   1              else {incx=-1;delta_x=-delta_x;} 
 234   1              if(delta_y>0)incy=1; 
 235   1              else if(delta_y==0)incy=0;//Level
 236   1              else{incy=-1;delta_y=-delta_y;} 
 237   1              if( delta_x>delta_y)distance=delta_x; //Select the basic incremental axis
 238   1              else distance=delta_y; 
 239   1              for(t=0;t<=distance+1;t++ )//Drawing a line output
 240   1              {  
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 5   

 241   2                      LCD_DrawPoint(uRow,uCol);//Dotted 
 242   2                      xerr+=delta_x ; 
 243   2                      yerr+=delta_y ; 
 244   2                      if(xerr>distance) 
 245   2                      { 
 246   3                              xerr-=distance; 
 247   3                              uRow+=incx; 
 248   3                      } 
 249   2                      if(yerr>distance) 
 250   2                      { 
 251   3                              yerr-=distance; 
 252   3                              uCol+=incy; 
 253   3                      } 
 254   2              }  
 255   1      }    
 256          //Draw a rectangle
 257          void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)
 258          {
 259   1              LCD_DrawLine(x1,y1,x2,y1);
 260   1              LCD_DrawLine(x1,y1,x1,y2);
 261   1              LCD_DrawLine(x1,y2,x2,y2);
 262   1              LCD_DrawLine(x2,y1,x2,y2);
 263   1      }
 264          //A circle the size of the appointed position draw
 265          //(x,y):The center
 266          //r    :Radius
 267          void Draw_Circle(u16 x0,u16 y0,u8 r)
 268          {
 269   1              int a,b;
 270   1              int di;
 271   1              a=0;b=r;          
 272   1              di=3-(r<<1);             //Judgment flag next point position
 273   1              while(a<=b)
 274   1              {
 275   2                      LCD_DrawPoint(x0-b,y0-a);             //3           
 276   2                      LCD_DrawPoint(x0+b,y0-a);             //0           
 277   2                      LCD_DrawPoint(x0-a,y0+b);             //1       
 278   2                      LCD_DrawPoint(x0-b,y0-a);             //7           
 279   2                      LCD_DrawPoint(x0-a,y0-b);             //2             
 280   2                      LCD_DrawPoint(x0+b,y0+a);             //4               
 281   2                      LCD_DrawPoint(x0+a,y0-b);             //5
 282   2                      LCD_DrawPoint(x0+a,y0+b);             //6 
 283   2                      LCD_DrawPoint(x0-b,y0+a);             
 284   2                      a++;
 285   2                      //Using the Bresenham algorithm Circle
 286   2                      if(di<0)di +=4*a+6;       
 287   2                      else
 288   2                      {
 289   3                              di+=10+4*(a-b);   
 290   3                              b--;
 291   3                      } 
 292   2                      LCD_DrawPoint(x0+a,y0+b);
 293   2              }
 294   1      } 
 295          //Displays a character at the specified position
 296          
 297          // num "" ---> "~"
 298          // mode: overlay mode (1) or non-overlapping mode (0)
 299          // Display a character at the specified location
 300          
 301          void LCD_ShowChar(u16 x,u16 y,u8 num,u8 mode)
 302          {
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 6   

 303   1          u8 temp;
 304   1          u8 pos,t;
 305   1              u16 x0=x;
 306   1              u16 colortemp=POINT_COLOR;      
 307   1          if(x>LCD_W-16||y>LCD_H-16)return;       
 308   1              //Settings window          
 309   1              num=num-' ';//Obtained after the offset value
 310   1              Address_set(x,y,x+8-1,y+16-1);      //Setting the cursor position
 311   1              if(!mode) //Non-overlapping mode
 312   1              {
 313   2                      for(pos=0;pos<16;pos++)
 314   2                      { 
 315   3                              temp=asc2_1608[(u16)num*16+pos];                 //Call 1608 fonts
 316   3                              for(t=0;t<8;t++)
 317   3                          {                 
 318   4                              if(temp&0x01)POINT_COLOR=colortemp;
 319   4                                      else POINT_COLOR=BACK_COLOR;
 320   4                                      LCD_WR_DATA(POINT_COLOR);       
 321   4                                      temp>>=1; 
 322   4                                      x++;
 323   4                          }
 324   3                              x=x0;
 325   3                              y++;
 326   3                      }       
 327   2              }else//Superimposition
 328   1              {
 329   2                      for(pos=0;pos<16;pos++)
 330   2                      {
 331   3                          temp=asc2_1608[(u16)num*16+pos];             //Call 1608 fonts
 332   3                              for(t=0;t<8;t++)
 333   3                          {                 
 334   4                              if(temp&0x01)LCD_DrawPoint(x+t,y+pos);//Draw a point
 335   4                              temp>>=1; 
 336   4                          }
 337   3                      }
 338   2              }
 339   1              POINT_COLOR=colortemp;                            
 340   1      }   
 341          // m ^ n function
 342          u32 mypow(u8 m,u8 n)
 343          {
 344   1              u32 result=1;    
 345   1              while(n--)result*=m;    
 346   1              return result;
 347   1      }                        
 348          // Show two figures
 349          // x, y: starting point coordinates
 350          // len: Digits
 351          // color: color
 352          // num: value (0 to 4294967295);
 353          void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len)
 354          {               
 355   1              u8 t,temp;
 356   1              u8 enshow=0;
 357   1              num=(u16)num;
 358   1              for(t=0;t<len;t++)
 359   1              {
 360   2                      temp=(num/mypow(10,len-t-1))%10;
 361   2                      if(enshow==0&&t<(len-1))
 362   2                      {
 363   3                              if(temp==0)
 364   3                              {
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 7   

 365   4                                      LCD_ShowChar(x+8*t,y,' ',0);
 366   4                                      continue;
 367   4                              }else enshow=1; 
 368   3                               
 369   3                      }
 370   2                      LCD_ShowChar(x+8*t,y,temp+48,0); 
 371   2              }
 372   1      } 
 373          // Show two figures
 374          // x, y: starting point coordinates
 375          // num: number (0 to 99);        
 376          void LCD_Show2Num(u16 x,u16 y,u16 num,u8 len)
 377          {               
 378   1              u8 t,temp;                                                 
 379   1              for(t=0;t<len;t++)
 380   1              {
 381   2                      temp=(num/mypow(10,len-t-1))%10;
 382   2                      LCD_ShowChar(x+8*t,y,temp+'0',0); 
 383   2              }
 384   1      } 
 385          // Display the string
 386          // x, y: starting point coordinates
 387          // * p: string starting address
 388          // With 16 fonts
 389          void LCD_ShowString(u16 x,u16 y,const u8 *p)
 390          {         
 391   1          while(*p!='\0')
 392   1          {       
 393   2              if(x>LCD_W-16){x=0;y+=16;}
 394   2              if(y>LCD_H-16){y=x=0;LCD_Clear(RED);}
 395   2              LCD_ShowChar(x,y,*p,0);
 396   2              x+=8;
 397   2              p++;
 398   2          }  
 399   1      }
 400          
 401          // Display a character (32 * 33 size) at the specified location
 402          // dcolor content color, gbcolor for Beijing color
 403          void show_char(unsigned int x,unsigned int y,unsigned char index)       
 404          {  
 405   1              unsigned char i,j;
 406   1              unsigned char *temp=symbol;    
 407   1          Address_set(x,y,x+31,y+31); //Settings area   
 408   1              temp+=index*128;        
 409   1              for(j=0;j<128;j++)
 410   1              {
 411   2                      for(i=0;i<8;i++)
 412   2                      {                    
 413   3                              if((*temp&(1<<i))!=0)
 414   3                              {
 415   4                                      LCD_WR_DATA(POINT_COLOR);
 416   4                              } 
 417   3                              else
 418   3                              {
 419   4                                      LCD_WR_DATA(BACK_COLOR);
 420   4                              }   
 421   3                      }
 422   2                      temp++;
 423   2               }
 424   1      }
 425          
 426          
C51 COMPILER V9.01   LCD_8BIT                                                              02/16/2015 16:42:10 PAGE 8   

 427          
 428          
 429          
 430          
 431          
 432          
 433          
 434          
 435          
 436          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2564    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4     115
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
